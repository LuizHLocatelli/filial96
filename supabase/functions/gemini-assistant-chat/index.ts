import { createClient } from "https://esm.sh/@supabase/supabase-js@2.39.3";

const GEMINI_API_KEY = Deno.env.get("GEMINI_API_KEY");
const SUPABASE_URL = Deno.env.get("SUPABASE_URL")!;
const SUPABASE_SERVICE_ROLE_KEY = Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!;

const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

const corsHeaders = {
  "Access-Control-Allow-Origin": "*",
  "Access-Control-Allow-Headers": "authorization, x-client-info, apikey, content-type",
};

interface MessagePart {
  text?: string;
  inlineData?: {
    mimeType: string;
    data: string;
  };
}

interface ChatMessage {
  role: "user" | "model";
  parts: MessagePart[];
}

interface RequestBody {
  message: string;
  systemMessage: string;
  images?: string[]; 
  history?: ChatMessage[];
}

Deno.serve(async (req) => {
  if (req.method === "OPTIONS") {
    return new Response("ok", { headers: corsHeaders });
  }

  try {
    const body = await req.json() as RequestBody;
    const message = body.message;
    const systemMessage = body.systemMessage;
    const images = body.images || [];
    const history = body.history || [];

    if (!message) {
      throw new Error("Message is required");
    }

    // 1. Setup the system instruction to conditionally use the image model
    const imageInstruction = `
[IMPORTANT INSTRUCTION FOR IMAGE GENERATION]
You have the ability to generate images using a specialized secondary model (gemini-3.1-flash-image-preview).
If the user explicitly asks you to create, generate, draw, or make an image or picture, you MUST respond with a JSON block in exactly this format and nothing else:
\`\`\`json
{
  "action": "generate_image",
  "prompt": "<detailed prompt describing the image in english>"
}
\`\`\`
Do not include any conversational text outside the JSON block if you are generating an image. If the user is NOT asking for an image, respond normally to the conversation.
`;
    const finalSystemMessage = systemMessage + "\n\n" + imageInstruction;

    const chatModelName = "gemini-3-flash-preview";
    const chatUrl = `https://generativelanguage.googleapis.com/v1beta/models/${chatModelName}:generateContent?key=${GEMINI_API_KEY}`;

    const currentMessageParts: MessagePart[] = [{ text: message }];

    for (const img of images) {
      let mimeType = "image/jpeg";
      let base64Data = img;
      
      if (img.startsWith("data:")) {
        const parts = img.split(";base64,");
        if (parts.length === 2) {
          mimeType = parts[0].replace("data:", "");
          base64Data = parts[1];
        }
      }
      
      if (base64Data) {
        currentMessageParts.push({
          inlineData: { mimeType, data: base64Data }
        });
      }
    }

    const currentTurn: ChatMessage = { role: "user", parts: currentMessageParts };
    const contents = [...history, currentTurn];

    // Request Chat Model
    console.log(`Calling Chat Model (${chatModelName})...`);
    const chatRes = await fetch(chatUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        systemInstruction: { parts: [{ text: finalSystemMessage }] },
        contents: contents,
        generationConfig: { temperature: 0.7 }
      })
    });

    if (!chatRes.ok) {
      const err = await chatRes.text();
      throw new Error(`Chat API error: ${err}`);
    }

    const chatData = await chatRes.json();
    let generatedText = chatData.candidates?.[0]?.content?.parts?.[0]?.text;
    const generatedImages: string[] = [];

    if (!generatedText) {
      throw new Error("No text generated by Gemini API");
    }

    // 2. Check if the model decided to generate an image
    let jsonStr = generatedText.trim();
    const jsonMatch = generatedText.match(/```(?:json)?\n([\s\S]*?)\n```/);
    if (jsonMatch) {
      jsonStr = jsonMatch[1].trim();
    }
    
    if (jsonStr.startsWith('{') && jsonStr.includes('"generate_image"')) {
      try {
        const parsed = JSON.parse(jsonStr);
        if (parsed.action === "generate_image" && parsed.prompt) {
          console.log("Generating image with prompt:", parsed.prompt);
          
          const imageModelName = "gemini-3.1-flash-image-preview";
          const imageUrl = `https://generativelanguage.googleapis.com/v1beta/models/${imageModelName}:generateContent?key=${GEMINI_API_KEY}`;
          
          const imgRes = await fetch(imageUrl, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
               contents: [{ role: "user", parts: [{ text: parsed.prompt }] }]
            })
          });

          if (!imgRes.ok) {
             const err = await imgRes.text();
             console.error("Image generation failed:", err);
             generatedText = "Desculpe, ocorreu um erro ao tentar gerar a imagem. (" + err + ")";
          } else {
             const imgData = await imgRes.json();
             
             // Extract base64 image
             const candidates = imgData.candidates || [];
             let base64Image = null;
             let mimeType = "image/png";

             for (const cand of candidates) {
               if (cand.content && cand.content.parts) {
                 for (const part of cand.content.parts) {
                   if (part.inlineData) {
                     base64Image = part.inlineData.data;
                     mimeType = part.inlineData.mimeType || "image/png";
                     break;
                   }
                 }
               }
               if (base64Image) break;
             }

             if (base64Image) {
                // Upload to Supabase Storage
                const extension = mimeType.split('/')[1] || 'png';
                const fileName = `generated-${Date.now()}-${Math.random().toString(36).substring(7)}.${extension}`;
                
                // convert base64 to Uint8Array for supabase upload
                const binaryString = atob(base64Image);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                  bytes[i] = binaryString.charCodeAt(i);
                }

                console.log(`Uploading ${fileName} to Supabase storage...`);
                const { data: uploadData, error: uploadError } = await supabase.storage
                  .from("ai-chat-attachments")
                  .upload(fileName, bytes.buffer, {
                    contentType: mimeType,
                    cacheControl: '3600',
                    upsert: false
                  });

                if (uploadError) {
                  console.error("Storage upload error:", uploadError);
                  generatedText = "A imagem foi gerada, mas houve um erro ao salvá-la no banco de dados.";
                } else {
                  const { data: { publicUrl } } = supabase.storage
                    .from("ai-chat-attachments")
                    .getPublicUrl(fileName);
                  
                  generatedImages.push(publicUrl);
                  generatedText = "Aqui está a imagem que você solicitou.";
                }
             } else {
                generatedText = "O modelo processou seu pedido, mas não retornou nenhuma imagem válida.";
             }
          }
        }
      } catch (e) {
        console.error("Failed to parse JSON for image generation:", e);
        // Fallback to the original text
      }
    }

    return new Response(
      JSON.stringify({ text: generatedText, images: generatedImages }),
      { headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  } catch (error) {
    console.error("Function error:", error);
    return new Response(
      JSON.stringify({ error: error.message }),
      { status: 500, headers: { ...corsHeaders, "Content-Type": "application/json" } }
    );
  }
});
